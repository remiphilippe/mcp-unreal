<!-- Source: https://dev.epicgames.com/documentation/en-us/unreal-engine/procedural-content-generation-overview -->

The **Procedural Content Generation Framework (PCG)** is a toolset for creating your own procedural content and tools inside Unreal Engine. PCG provides technical artists, designers, and programmers with the ability to build fast, iterative tools and content of any complexity, ranging from Asset utilities, such as buildings or biome generation, up to entire worlds.

## Important Concepts and Terms

- **Points**: Locations in 3D space that are generated by the PCG graph and are often used to spawn meshes. Points contain information about their transforms, bounds, color, density, steepness, and seed. They can be assigned user-defined attributes.

- **Point Density**: Value used by a variety of graph nodes. This is represented in the debug view as a gradient on each point and represents the probability of the point to exist at that position. A density of 0 is black, and a density of 1 is white.


## Required Setup

The Procedural Content Generation Framework requires the **Procedural Content Generation Framework** plugin to be enabled in your project. For more information on enabling plugins, see [Working with Plugins](https://dev.epicgames.com/documentation/en-us/unreal-engine/working-with-plugins-in-unreal-engine).

The **Procedural Content Generation Framework Geometry Script Interop** plugin is required to sample points on Static Meshes.

## The Procedural Node Graph

The Procedural Node Graph is the central piece of the Procedural Content Generation Framework.

Using a format similar to the Material Editor, spatial data flows into the graph from a PCG Component in your Level and is used to generate points. The points are filtered and modified through a series of nodes, with the output being updated in real time. The resulting points can be used to spawn a variety of Assets.

### Create the PCG Graph Asset

To create a PCG Graph Asset, follow the steps below:

1. Right click in the **Content Drawer** or **Content Browser**, navigate to **Create Advanced Asset > PCG**, and select **PCG Graph**.

2. Choose a name for the new Asset and press **Enter**.


### PCG Graph Templates

After creating a PCG Graph, you can mark the graph as a template, which can then be selected from the context menu when creating new graphs. Similar to Niagara templates, you can expedite your workflow using a PCG graph template rather than starting from a blank graph.

#### Set a PCG Graph as a Template

To define a PCG Graph as a template, open the Graph and use the following steps:

1. In the Tool Bar, click the **Graph Settings** button to populate the Details panel with the graph settings.

2. Navigate to the Asset Info section of the Details panel and enable the Is Template property.

Your graph is now defined as a Template Graph.

#### Creating a New Graph using a Template

When creating a new graph, after the asset name and location has been chosen, you can now select a Graph Template from the **Create Graph From Template** window. Select the Graph Template you want to use and then click the **Initialize From Template** button to create a new graph using the template.

To disable the template prompt when creating new PCG Graphs, navigate in the menu bar to **Edit** > **Editor Preferences**. Then use the search bar or navigate to the **PCG Editor** section of properties and disable the **Show Template Picker** **on New Graph** property.

### Editing the PCG Graph

Using the PCG Graph Editor, you can configure and edit your PCG Graph Assets. Navigating the editor is similar to the Blueprint or Material editor. It also contains some PCG specific tools and panels.

| Number | Description |
| --- | --- |
| **1** | Toolbar |
| **2** | Node Palette |
| **3** | Viewport |
| **4** | Details panel |
| **5** | Debug Tree |
| **6** | Attributes list |

Similar to working with Blueprints, you can add nodes to the graph by dragging them into the viewport from the Node Palette or by using the context menu.

Changes made to a PCG Graph update in real time in the Editor viewport when the graph is assigned to a PCG Component and has been used to generate content.

### PCG Nodes

The PCG Graph is made of a series of PCG Nodes, each one performing an operation that contributes to the final result.

These nodes are divided into the following categories:

| Category | Description |
| --- | --- |
| **Blueprint** | Contains Blueprint-related nodes. This includes the common node to execute user Blueprints derived from **PCGBlueprintElement**. |
| **Control Flow** | Contains nodes for controlling the flow of logic through the graph. |
| **Debug** | Contains nodes that help with debugging. |
| **Density** | Contains nodes that affect point density. |
| **Filter** | Contains nodes that filter data based on criteria or per-point. |
| **Generic** | Contains nodes that affect data, but not spatial data. |
| **Hierarchical Generation** | Contains nodes for controlling the Hierarchical Generation mode. |
| **Input Output** | Contains nodes for loading Alembic and other external data. |
| **IO** | Contains nodes that control interaction with external data. |
| **Metadata** | Contains nodes that interact with Attributes, whether on points or on Attribute Sets. |
| **Param** | Contains nodes that control retrieval of parameters from Actors or Blueprint variables. |
| **Point Ops** | Contains nodes that affect points and their properties. |
| **Sampler** | Contains nodes that generate points from a source of spatial data, such as volumes, surfaces, and meshes. |
| **Spatial** | Contains nodes that create spatial relationships between data, change their internal spatial data, or retrieve data. |
| **Spawner** | Contains nodes that create new data or place Actors at given point locations. |
| **Subgraph** | Contains nodes that deal with using subgraphs. |

Like Blueprints, you can add **Comments** and **Reroute Nodes** to improve the readability of your graph.

### Graph Editing Customization

Editing PCG Graphs can be customized using a dedicated set of properties that you can access in the **Graph Settings** panel.

With these properties, you can customize your PCG Graph's behavior and workflow for a more curated experience. These settings can then be used to build a PCG Graph Template which can tailor your PCG Graph workflow for your project.

#### Node Filtering

You can use the Node Filter settings to filter node selections by category. Filtering is done on an include or exclude basis. To filter nodes in the selection context-menu, **enable** the **Filter Nodes by Category** property, then add an index to the **Filtered Categories** property using the **Add** ( **+**) button. After adding an Index you can then type the category name in the text field, or use the drop-down menu to select a node category.

Changing the filters will update the selection available from the node palette and also from the contextual menu.

#### Graph filtering

In addition to filtering the available nodes for the Graph, you can also filter the available subgraphs. Similar to Node Filtering, first **enable** the **Filter Subgraph** property, then **Add** ( **+**) a new index, and select the subgraph you want to be selectable in the graph.

### Attributes and Metadata

Attributes are similar to variables and store data defined by its name and type. There are two types of Attributes:

- **Static Attributes**: Attributes that are fixed and always present. These start with a `$`, such as `$Position`.

- **Dynamic Attributes**: Attributes that are created at runtime, and stored as part of the **Metadata** of the graph data.


### Metadata Domains

When using Attributes in PCG Graphs, you must consider the Domain the Metadata exists in. The domain will control what kind of information you can save as well as how it can be used and manipulated later. For each metadata point must know which domain is supported, and which domain is the default. Domains are prefixed by `@` when selecting them.

There are three domains that you can use when working with PCG Graphs. First, you can use the **Data** domain for attributes that are set for the data itself. The Data domain is restricted to single values, meaning you can't store multiple values like attribute sets. The Data domain can be manipulated the same as other domains. You can create or add attributes to it, or manipulate it with metadata operations, if you prefix the attribute with `@Data`. For example, an attribute `MyAttr` in the data domain, would be `@Data.MyAttr`. The Data domain is the default domain for all other spatial data, the domain `@Data` is the default. When there is no domain specified.

The second domain is the Points domain using the prefix `@Points`.

The third domain is the Elements domain, which is used for Attribute sets, and uses the `@Elements` prefix.

### Attribute Selector

Some PCG graph nodes can be used to provide interoperability between static attributes and dynamic attributes through the Attribute Selector.

The Attribute Selector provides you with a list of attributes that are available to use with the selected node. The Attribute Selector uses the following naming rules:

- Names starting with a $ are static attributes, while names without are dynamic attributes.

- `@Last` represents the last dynamic attribute that was manipulated by the previous node.

For example, the Math node is used to perform mathematical operations on static and dynamic attributes.

The Attribute Selector name field can also be used to extract data from components. For example, `$Position.ZYX` provides the inverse of the components of $Position. Below are the components that can be manipulated in this way and their types:

| Component | Type |
| --- | --- |
| **Vectors** |  |
| X, Y, Z, W, x, y, z, w | Double. Can't be mixed with RGBA. |
| R, G, B, A, r, g, b, a | Double. Can't be mixed with XYZW. |
| Length, Size | Double. Returns vector length. |
| **Transforms** |  |
| Location, Position | Vector3 |
| Scale, Scale3D | Vector3 |
| Rotation | Quaternion |
| **Rotators** |  |
| Pitch, Yaw, Roll | Double |
| Forward, Right, Up | Vector3 |
| **Quaternions** |  |
| Support Vector extractor | Vector |
| Support Rotator extractor | Rotator |

### C++ Settings Overrides

Some settings are marked as PCG_Overridable in the C++ property metadata. For Blueprint nodes, variables that are visible and instance editable are overridable.

Once overridden, pins are automatically added to the node as advanced pins. There are two types of pins:

- **Global override**: Accepts any number of attributes and overrides all settings for each attribute that is an exact match with the setting name.

- **Single override**: Accepts any number of attributes and overrides the specific setting if an attribute is found with an exact match with the setting name, or any name if there is only one attribute.

Attribute types need to match but some types can be converted.

Since the domains are specific to each data, the C++ API of `UPCGData` has functions to know which domains are supported, and to convert back and forth between `FPCGMetadataDomainID`, which is the internal class to specify a metadata domain, and `FPCGAttributePropertySelector`, which is the exposed class to select Attributes and Properties. Each `FPCGMetadataDomain` has its own set of attributes and entries, they are independent from each other. Accessors are updated to access the right domain, using the `FPCGAttributePropertySelector`.

### Spline Metadata Example

The following sections will provide some example setups of practical PCG Metadata workflows.

#### Spline Attributes

Using attributes you can manipulate control points properties directly. You can access the following list of Attribute properties using **Add** ( **+**) > **Spline** > **Control Points**.

| Name | Description | Type |
| --- | --- | --- |
| $Position | Location component of the control point's transform (in world referential) | Vector |
| $Rotation | Rotation component of the control point's transform (in world referential) | Quaternion/Rotator |
| $Scale | Scale component of the control point's transform (in world referential) | Vector |
| $Transform | World transform of the control point | Transform |
| $ArriveTangent | Arrive Tangent at the control point | Vector |
| $LeaveTangent | Leave Tangent at the control point | Vector |
| $InterpType | Type of interpolation at the control point for position (same as set on the spline control point) | ESplinePointType |
| $LocalPosition | Local position of the control point | Vector |
| $LocalRotation | Rotation component of the control point's transform (in spline referential) | Quaternion/Rotator |
| $LocalScale | Scale component of the control point's transform (in spline referential) | Vector |
| $LocalTransform | Local transform of the control point | Transform |

#### Spline Data

You can also manipulate data properties directly. You can access the following list of Data properties using **Add** ( **+**) > **Spline** > **Global**.

| Name | Description | Type |
| --- | --- | --- |
| @Data.$SplineTransform | Transform of the spline | FTransform |
| @Data.$IsClosed | If the spline is closed or not (Read Only) | bool |

#### Spline Metadata

On top of control point properties, you can add attributes to the spline data, attached to the control points. This metadata will be interpolated when we sample the spline. Metadata like this is behaving the same as the point or attribute set metadata.

Similar to points, you can use **Add Attribute** to create a new attribute, or use the metadata operations and specify a given output target to write into this attribute.

In addition, Metadata on control points is the default for spline metadata, but you can also be explicit with `@ControlPoints`.

### Graph Parameters

Similar to parameters in the Material editor, PCG Graph Parameters are user created overridable values and can help create customizable graphs for a variety of situations. To create a new parameter:

1. Open the PCG Graph Settings.

2. Click the + button next to Parameters. This creates a new parameter.

3. Click the down arrow next to the new parameter. Rename it and select the type.

To change the value of a parameter on a PCG Graph, change the value in the Graph Parameters or in the Details panel of a PCG asset.

To change the value of a parameter on a PCG Graph Instance, open the asset in the Content Browser and change the value or in the Details panel of a PCG asset.

### Graph Instances

PCG Graph Instances work similar to Material Instances and utilize Graph Parameters to help you reuse your existing graphs as instances or PCG Subgraphs.

To create a PCG Graph instance:

1. Select a PCG asset in your level.

2. Select the PCG component in the Details panel

3. Click the **Save Instance** button to create a new instance.

4. Name your new graph instance and press **Enter**.

When using an instance as a PCG Subgraph, parameters can be overridden using the override pins on the subgraph node.

## PCG Component

The Procedural Node Graph can sample your Level through the PCG Component. This component holds an instance of your Procedural Node Graph and manages the generation of procedural content, both in the Editor and at runtime. PCG components are added as a component to an Actor or used as part of the PCG Volume, a basic volume useful for quickly setting up procedural content.

To connect a PCG graph to your PCG component, follow the steps below:

1. In the Editor viewport or **Outliner**, select the **PCG Volume** or **Blueprint Class** that you want to connect.

2. In the **Details** panel, click the **PCG Component**.

3. Click the **Graph** dropdown and select the PCG Node Graph you want to use.

4. Click the **Generate** button to see your result.


## World Partition Support

When PCG assets are assigned to a [World Partition - Data Layer](https://dev.epicgames.com/documentation/en-us/unreal-engine/world-partition---data-layers-in-unreal-engine) and an [HLOD Layer](https://dev.epicgames.com/documentation/en-us/unreal-engine/world-partition---hierarchical-level-of-detail-in-unreal-engine), the PCG graph generates the actors and assigns them to the same data layer and the same HLOD layer.

For more information about using PCG with World Partition, see [Using PCG with World Partition](https://dev.epicgames.com/documentation/en-us/unreal-engine/using-pcg-with-world-partition-in-unreal-engine).

## Debugging in PCG

Debugging is an essential part of the PCG workflow.

Each node has a variety of debug options that you can use to visualize the point data at each step of the PCG graph:

- Debug Rendering
- Enable / Disable node
- Inspect

Toggle Debug Rendering for each node by selecting the checkbox for **Debug** in the node's **Details** panel or by pressing the **D** key.

Toggle each node on and off by selecting the checkbox for **Enabled** in the node's **Details** panel or by pressing the **E** key.

You can also display all the points a node generates in the **Attributes** list by inspecting the node.

1. Select your PCG component from the Debug Tree.

2. Right-click the node you want to inspect.

3. Select Inspect. Alternatively, you can press the A key.


## Create a Simple Forest Volume

A common use case for procedural generation tools is biome generation in an open world environment.

### Create the Level

1. [Create a new Project](https://dev.epicgames.com/documentation/en-us/unreal-engine/creating-a-new-project-in-unreal-engine) in Unreal Engine.

2. [Create a new Level](https://dev.epicgames.com/documentation/en-us/unreal-engine/working-with-levels-in-unreal-engine) using the **Basic** level template. Save your Level.

3. Delete the **Floor** Static Mesh and add a new Landscape to the level using Landscape mode.

4. Using the Sculpt tools, add some variation to your Landscape.


### Create the PCG Volume

1. Return to **Selection** Mode and enable the **Place Actors** window, if it's not currently visible.

2. Use the **Search Classes** box to find the **PCG Volume** and add one to your level.

3. Scale the PCG Volume to X=8.0, Y=8.0, Z=8.0


### Create the PCG Graph Asset

1. Right click in the **Content Drawer** or **Content Browser**, navigate to **Create Advanced Asset > PCG**, and select **PCG Graph**.

2. Name the new asset **PCG_ForestGen** and press **Enter**.

3. Double-click **PCG_ForestGen** to open the PCG Graph Editor.


### Connect the PCG Component

1. In the Editor viewport or **Outliner**, select the **PCG Volume**.

2. In the **Details** panel, click the **PCG Component**.

3. Click the **Graph** dropdown and select **PCG_ForestGen** from the list.


### Create the Points

1. In the PCG Graph Editor window, add a **Get Landscape Data** node to the graph.

2. Drag from the output of Get Landscape Data and add a **Surface Sampler** node.

3. Select the Surface Sampler and press the **D** key to toggle Debug Rendering.

4. Back in the Editor window, select the PCG Volume and click the **Generate** button in the Details panel.

You can now see the points being generated in the Editor viewport. The points conform to the shape of the Landscape.

### Add Variation

1. In the PCG Graph Editor, select the Surface Sampler.

2. Add more points by adjusting the **Points Per Square Meter**, **Points Extents**, and **Looseness** properties in the Details panel.
   - Adjust the **Points Per Square Meter** to **0.15** to add more points to the space.
   - The **Points Extends** property controls the size of each point's bounds. Change the **X**, **Y**, and **Z** values to **50**.
   - The Looseness property determines how closely the generated points conform to a grid shape. Leave the **Looseness** value at **1.0**.

3. Next, add a **Transform Points** node. This node adds additional movement, rotation, and scale changes to your points with a defined range. Connect the **Output** pin of the Surface Sampler node to the **Input** pin of the Transform Points node.

4. Disable Debug Rendering on the Surface Sampler node and enable it on the Transform Points node.

5. To add some rotation variation, change the **Z** value for the **Max Rotation** to **360**. This gives all the points a random rotation between 0 and 360 degrees.

6. The PCG graph spawns points and rotates them to conform with the normal direction of the Landscape. Disable this extra rotation by selecting the checkbox for **Absolute Rotation**.

7. To add some size variation set the **X**, **Y**, and **Z** **Scale Min** values to **0.5**. Change the **X**, **Y**, and **Z** **Scale Max** values to **1.2**.

The end result is a set of points with a good amount of variation.

### Spawn the Static Meshes

1. In the PCG Graph Editor, add a **Static Mesh Spawner** node to the graph viewport. Connect the **Output** pin of the Transform Points node to the **Input** pin of the Static Mesh Spawner.

2. Select the Static Mesh Spawner.

3. In the **Details** panel, locate the **Mesh Entries** option and click the **+** button to add a Static Mesh to spawn.

4. Click the down arrow next to **Mesh Entries** to open the array.

5. Click the down arrow next to **Index [0]**.

6. Click the down arrow next to **Descriptor**.

7. Click the dropdown menu for **Static Mesh** and select the tree that you want to spawn.

You can add additional Static Meshes and balance the variety using the Weight property for each mesh entry in the array. Unreal Engine adds the weight value of all the Static Mesh entries and divides that number by each individual weight to determine the probability of each entry spawning.
